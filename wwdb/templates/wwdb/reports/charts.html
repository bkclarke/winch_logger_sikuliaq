<!doctype html>
{% extends "wwdb/base.html" %}
{% load static %}

{% block content %}

<h1>Winch Plots</h1>
<br>
<form method="get" id="dateRangeForm" class="row g-3 align-items-center">
    <div class="col-auto">
        <label for="start_date" class="col-form-label">Start Date:</label>
    </div>
    <div class="col-auto">
        <input type="date" id="start_date" name="start_date"
               class="form-control"
               value="{{ form.start_date.value|date:'Y-m-d'|default_if_none:'' }}" required>
    </div>

    <div class="col-auto">
        <label for="end_date" class="col-form-label">End Date:</label>
    </div>
    <div class="col-auto">
        <input type="date" id="end_date" name="end_date"
               class="form-control"
               value="{{ form.end_date.value|date:'Y-m-d'|default_if_none:'' }}" required>
    </div>

    <div class="col-auto">
        {{ form.winch }}
    </div>
    <div class="col-auto">
        <button type="submit" class="btn btn-primary">Filter Data</button>
    </div>
</form>
<br />
<br />
<div id="container" style="width: 100%; height: 400px;"></div>
<br>
<br>

<script type="text/javascript">
    document.addEventListener('DOMContentLoaded', function () {
        var startDateInput = document.getElementById('start_date');
        var endDateInput = document.getElementById('end_date');

        var currentDate = new Date();
        var currentDateString = currentDate.toISOString().split('T')[0];
        var oneDayAgo = new Date();
        oneDayAgo.setDate(currentDate.getDate() - 1);
        var oneDayAgoString = oneDayAgo.toISOString().split('T')[0];

        if (startDateInput && endDateInput) {
            startDateInput.value = oneDayAgoString;
            endDateInput.value = currentDateString;

            endDateInput.setAttribute('max', currentDateString);

            startDateInput.addEventListener('change', function () {
                var startDate = new Date(startDateInput.value);
                var endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + 14);
                endDateInput.setAttribute('min', startDateInput.value);
                endDateInput.setAttribute('max', endDate.toISOString().split('T')[0]);
                endDateInput.value = '';
            });

            endDateInput.addEventListener('change', function () {
                validateDateRange();
            });
        }

        function validateDateRange() {
            var startDate = new Date(startDateInput.value);
            var endDate = new Date(endDateInput.value);
            if (startDate >= endDate) {
                alert('Start date must be before end date.');
                endDateInput.value = '';
            }
        }

        var noDbConnection = {{ no_db_connection|yesno:"true,false"}};
        var data_tension = {{ data_json_tension|safe }};
        var data_payout = {{ data_json_payout|safe }};

        const chart = Highcharts.chart('container', {
            chart: {
                type: 'line',
                zoomType: 'x',
                events: {
                    load: function () {
                        if (noDbConnection) {
                            this.customNoDataLabel = this.renderer.text(
                                'No database connection',
                                this.plotLeft + this.plotWidth / 2 - 100,
                                this.plotTop + this.plotHeight / 2
                            ).css({
                                color: 'red',
                                fontSize: '16px',
                                fontWeight: 'bold'
                            }).attr({ zIndex: 5 }).add();
                            return;
                        }
                        updateMaxTensionPlotLine(this);
                    }
                }
            },
            title: {
                text: 'Tension, Payout vs. Time'
            },
            xAxis: {
                type: 'datetime',
                title: { text: 'Date' },
                events: {
                    afterSetExtremes: function () {
                        if (!noDbConnection) {
                            updateMaxTensionPlotLine(this.chart);
                        }
                    }
                }
            },
            yAxis: [{
                title: { text: 'Tension (lbs)' },
                labels: { format: '{value} lbs' }
            }, {
                title: { text: 'Payout (m)' },
                labels: { format: '{value} m' },
                opposite: true
            }],
            series: [{
                name: 'Tension',
                yAxis: 0,
                data: data_tension.map(p => [new Date(p.date).getTime(), p.value])
            }, {
                name: 'Payout',
                yAxis: 1,
                data: data_payout.map(p => [new Date(p.date).getTime(), p.value])
            }]
        });

    function updateMaxTensionPlotLine(chart) {
        const xAxis = chart.xAxis[0];
        const min = xAxis.min;
        const max = xAxis.max;

        const visibleTensionData = data_tension.filter(p => {
            const time = new Date(p.date).getTime();
            return time >= min && time <= max;
        });

        const nonNullTension = visibleTensionData.filter(p => p.value !== null);

        // Remove previous no-data label if present
        if (chart.customNoDataLabel) {
            chart.customNoDataLabel.destroy();
            chart.customNoDataLabel = null;
        }

        // PlotBands for null regions
        const nullBands = [];
        let i = 0;
        while (i < visibleTensionData.length) {
            if (visibleTensionData[i].value === null) {
                // Find start of null region
                let startIdx = i;
                while (i < visibleTensionData.length && visibleTensionData[i].value === null) {
                    i++;
                }
                // i is now at first non-null after a block of nulls
                let prev = visibleTensionData[startIdx - 1];
                let next = visibleTensionData[i];
                if (prev && next) {
                    nullBands.push({
                        color: 'rgba(150, 150, 150, 0.3)',
                        from: new Date(prev.date).getTime(),
                        to: new Date(next.date).getTime(),
                        zIndex: 1,
                        }
                    });
                }
            } else {
                i++;
            }
        }

        xAxis.update({
            plotLines: [],
            plotBands: nullBands
        });

        // Max tension plot line
        if (nonNullTension.length > 0) {
            const maxPoint = nonNullTension.reduce((a, b) => a.value > b.value ? a : b);
            const maxDate = new Date(maxPoint.date).getTime();

            xAxis.update({
                plotLines: [{
                    color: 'red',
                    width: 2,
                    value: maxDate,
                    label: {
                        text: 'Max Tension: ' + maxPoint.value,
                        align: 'left',
                        verticalAlign: 'bottom',
                        x: 10,
                        y: -20,
                        rotation: 0,
                        style: { color: 'red' }
                    }
                }]
            });
        } else {
            chart.customNoDataLabel = chart.renderer.text(
                'No values in the selected date range',
                chart.plotLeft + chart.plotWidth / 2 - 100,
                chart.plotTop + chart.plotHeight / 2
            ).css({
                color: 'gray',
                fontSize: '16px'
            }).attr({ zIndex: 5 }).add();
        }
    }

    });
</script>

{% endblock content %}


